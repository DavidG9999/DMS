// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v3.12.4
// source: document.proto

package docv1

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	Auto_CreateAuto_FullMethodName = "/document.Auto/CreateAuto"
	Auto_GetAutos_FullMethodName   = "/document.Auto/GetAutos"
	Auto_UpdateAuto_FullMethodName = "/document.Auto/UpdateAuto"
	Auto_DeleteAuto_FullMethodName = "/document.Auto/DeleteAuto"
)

// AutoClient is the client API for Auto service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type AutoClient interface {
	CreateAuto(ctx context.Context, in *CreateAutoRequest, opts ...grpc.CallOption) (*CreateAutoResponse, error)
	GetAutos(ctx context.Context, in *GetAutosRequest, opts ...grpc.CallOption) (*GetAutosResponse, error)
	UpdateAuto(ctx context.Context, in *UpdateAutoRequest, opts ...grpc.CallOption) (*UpdateAutoResponse, error)
	DeleteAuto(ctx context.Context, in *DeleteAutoRequest, opts ...grpc.CallOption) (*DeleteAutoResponse, error)
}

type autoClient struct {
	cc grpc.ClientConnInterface
}

func NewAutoClient(cc grpc.ClientConnInterface) AutoClient {
	return &autoClient{cc}
}

func (c *autoClient) CreateAuto(ctx context.Context, in *CreateAutoRequest, opts ...grpc.CallOption) (*CreateAutoResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateAutoResponse)
	err := c.cc.Invoke(ctx, Auto_CreateAuto_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *autoClient) GetAutos(ctx context.Context, in *GetAutosRequest, opts ...grpc.CallOption) (*GetAutosResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetAutosResponse)
	err := c.cc.Invoke(ctx, Auto_GetAutos_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *autoClient) UpdateAuto(ctx context.Context, in *UpdateAutoRequest, opts ...grpc.CallOption) (*UpdateAutoResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateAutoResponse)
	err := c.cc.Invoke(ctx, Auto_UpdateAuto_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *autoClient) DeleteAuto(ctx context.Context, in *DeleteAutoRequest, opts ...grpc.CallOption) (*DeleteAutoResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteAutoResponse)
	err := c.cc.Invoke(ctx, Auto_DeleteAuto_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AutoServer is the server API for Auto service.
// All implementations must embed UnimplementedAutoServer
// for forward compatibility.
type AutoServer interface {
	CreateAuto(context.Context, *CreateAutoRequest) (*CreateAutoResponse, error)
	GetAutos(context.Context, *GetAutosRequest) (*GetAutosResponse, error)
	UpdateAuto(context.Context, *UpdateAutoRequest) (*UpdateAutoResponse, error)
	DeleteAuto(context.Context, *DeleteAutoRequest) (*DeleteAutoResponse, error)
	mustEmbedUnimplementedAutoServer()
}

// UnimplementedAutoServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedAutoServer struct{}

func (UnimplementedAutoServer) CreateAuto(context.Context, *CreateAutoRequest) (*CreateAutoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateAuto not implemented")
}
func (UnimplementedAutoServer) GetAutos(context.Context, *GetAutosRequest) (*GetAutosResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAutos not implemented")
}
func (UnimplementedAutoServer) UpdateAuto(context.Context, *UpdateAutoRequest) (*UpdateAutoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateAuto not implemented")
}
func (UnimplementedAutoServer) DeleteAuto(context.Context, *DeleteAutoRequest) (*DeleteAutoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteAuto not implemented")
}
func (UnimplementedAutoServer) mustEmbedUnimplementedAutoServer() {}
func (UnimplementedAutoServer) testEmbeddedByValue()              {}

// UnsafeAutoServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to AutoServer will
// result in compilation errors.
type UnsafeAutoServer interface {
	mustEmbedUnimplementedAutoServer()
}

func RegisterAutoServer(s grpc.ServiceRegistrar, srv AutoServer) {
	// If the following call pancis, it indicates UnimplementedAutoServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&Auto_ServiceDesc, srv)
}

func _Auto_CreateAuto_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateAutoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AutoServer).CreateAuto(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Auto_CreateAuto_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AutoServer).CreateAuto(ctx, req.(*CreateAutoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Auto_GetAutos_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAutosRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AutoServer).GetAutos(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Auto_GetAutos_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AutoServer).GetAutos(ctx, req.(*GetAutosRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Auto_UpdateAuto_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateAutoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AutoServer).UpdateAuto(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Auto_UpdateAuto_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AutoServer).UpdateAuto(ctx, req.(*UpdateAutoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Auto_DeleteAuto_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteAutoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AutoServer).DeleteAuto(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Auto_DeleteAuto_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AutoServer).DeleteAuto(ctx, req.(*DeleteAutoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Auto_ServiceDesc is the grpc.ServiceDesc for Auto service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Auto_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "document.Auto",
	HandlerType: (*AutoServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateAuto",
			Handler:    _Auto_CreateAuto_Handler,
		},
		{
			MethodName: "GetAutos",
			Handler:    _Auto_GetAutos_Handler,
		},
		{
			MethodName: "UpdateAuto",
			Handler:    _Auto_UpdateAuto_Handler,
		},
		{
			MethodName: "DeleteAuto",
			Handler:    _Auto_DeleteAuto_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "document.proto",
}

const (
	Contragent_CreateContragent_FullMethodName = "/document.Contragent/CreateContragent"
	Contragent_GetContragents_FullMethodName   = "/document.Contragent/GetContragents"
	Contragent_UpdateContragent_FullMethodName = "/document.Contragent/UpdateContragent"
	Contragent_DeleteContragent_FullMethodName = "/document.Contragent/DeleteContragent"
)

// ContragentClient is the client API for Contragent service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ContragentClient interface {
	CreateContragent(ctx context.Context, in *CreateContragentRequest, opts ...grpc.CallOption) (*CreateContragentResponse, error)
	GetContragents(ctx context.Context, in *GetContragentsRequest, opts ...grpc.CallOption) (*GetContragentsResponse, error)
	UpdateContragent(ctx context.Context, in *UpdateContragentRequest, opts ...grpc.CallOption) (*UpdateContragentResponse, error)
	DeleteContragent(ctx context.Context, in *DeleteContragentRequest, opts ...grpc.CallOption) (*DeleteContragentResponse, error)
}

type contragentClient struct {
	cc grpc.ClientConnInterface
}

func NewContragentClient(cc grpc.ClientConnInterface) ContragentClient {
	return &contragentClient{cc}
}

func (c *contragentClient) CreateContragent(ctx context.Context, in *CreateContragentRequest, opts ...grpc.CallOption) (*CreateContragentResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateContragentResponse)
	err := c.cc.Invoke(ctx, Contragent_CreateContragent_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *contragentClient) GetContragents(ctx context.Context, in *GetContragentsRequest, opts ...grpc.CallOption) (*GetContragentsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetContragentsResponse)
	err := c.cc.Invoke(ctx, Contragent_GetContragents_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *contragentClient) UpdateContragent(ctx context.Context, in *UpdateContragentRequest, opts ...grpc.CallOption) (*UpdateContragentResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateContragentResponse)
	err := c.cc.Invoke(ctx, Contragent_UpdateContragent_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *contragentClient) DeleteContragent(ctx context.Context, in *DeleteContragentRequest, opts ...grpc.CallOption) (*DeleteContragentResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteContragentResponse)
	err := c.cc.Invoke(ctx, Contragent_DeleteContragent_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ContragentServer is the server API for Contragent service.
// All implementations must embed UnimplementedContragentServer
// for forward compatibility.
type ContragentServer interface {
	CreateContragent(context.Context, *CreateContragentRequest) (*CreateContragentResponse, error)
	GetContragents(context.Context, *GetContragentsRequest) (*GetContragentsResponse, error)
	UpdateContragent(context.Context, *UpdateContragentRequest) (*UpdateContragentResponse, error)
	DeleteContragent(context.Context, *DeleteContragentRequest) (*DeleteContragentResponse, error)
	mustEmbedUnimplementedContragentServer()
}

// UnimplementedContragentServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedContragentServer struct{}

func (UnimplementedContragentServer) CreateContragent(context.Context, *CreateContragentRequest) (*CreateContragentResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateContragent not implemented")
}
func (UnimplementedContragentServer) GetContragents(context.Context, *GetContragentsRequest) (*GetContragentsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetContragents not implemented")
}
func (UnimplementedContragentServer) UpdateContragent(context.Context, *UpdateContragentRequest) (*UpdateContragentResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateContragent not implemented")
}
func (UnimplementedContragentServer) DeleteContragent(context.Context, *DeleteContragentRequest) (*DeleteContragentResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteContragent not implemented")
}
func (UnimplementedContragentServer) mustEmbedUnimplementedContragentServer() {}
func (UnimplementedContragentServer) testEmbeddedByValue()                    {}

// UnsafeContragentServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ContragentServer will
// result in compilation errors.
type UnsafeContragentServer interface {
	mustEmbedUnimplementedContragentServer()
}

func RegisterContragentServer(s grpc.ServiceRegistrar, srv ContragentServer) {
	// If the following call pancis, it indicates UnimplementedContragentServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&Contragent_ServiceDesc, srv)
}

func _Contragent_CreateContragent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateContragentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ContragentServer).CreateContragent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Contragent_CreateContragent_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ContragentServer).CreateContragent(ctx, req.(*CreateContragentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Contragent_GetContragents_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetContragentsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ContragentServer).GetContragents(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Contragent_GetContragents_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ContragentServer).GetContragents(ctx, req.(*GetContragentsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Contragent_UpdateContragent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateContragentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ContragentServer).UpdateContragent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Contragent_UpdateContragent_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ContragentServer).UpdateContragent(ctx, req.(*UpdateContragentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Contragent_DeleteContragent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteContragentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ContragentServer).DeleteContragent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Contragent_DeleteContragent_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ContragentServer).DeleteContragent(ctx, req.(*DeleteContragentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Contragent_ServiceDesc is the grpc.ServiceDesc for Contragent service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Contragent_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "document.Contragent",
	HandlerType: (*ContragentServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateContragent",
			Handler:    _Contragent_CreateContragent_Handler,
		},
		{
			MethodName: "GetContragents",
			Handler:    _Contragent_GetContragents_Handler,
		},
		{
			MethodName: "UpdateContragent",
			Handler:    _Contragent_UpdateContragent_Handler,
		},
		{
			MethodName: "DeleteContragent",
			Handler:    _Contragent_DeleteContragent_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "document.proto",
}

const (
	Dispetcher_CreateDispetcher_FullMethodName = "/document.Dispetcher/CreateDispetcher"
	Dispetcher_GetDispetchers_FullMethodName   = "/document.Dispetcher/GetDispetchers"
	Dispetcher_UpdateDispetcher_FullMethodName = "/document.Dispetcher/UpdateDispetcher"
	Dispetcher_DeleteDispetcher_FullMethodName = "/document.Dispetcher/DeleteDispetcher"
)

// DispetcherClient is the client API for Dispetcher service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type DispetcherClient interface {
	CreateDispetcher(ctx context.Context, in *CreateDispetcherRequest, opts ...grpc.CallOption) (*CreateDispetcherResponse, error)
	GetDispetchers(ctx context.Context, in *GetDispetchersRequest, opts ...grpc.CallOption) (*GetDispetchersResponse, error)
	UpdateDispetcher(ctx context.Context, in *UpdateDispetcherRequest, opts ...grpc.CallOption) (*UpdateDispetcherResponse, error)
	DeleteDispetcher(ctx context.Context, in *DeleteDispetcherRequest, opts ...grpc.CallOption) (*DeleteDispetcherResponse, error)
}

type dispetcherClient struct {
	cc grpc.ClientConnInterface
}

func NewDispetcherClient(cc grpc.ClientConnInterface) DispetcherClient {
	return &dispetcherClient{cc}
}

func (c *dispetcherClient) CreateDispetcher(ctx context.Context, in *CreateDispetcherRequest, opts ...grpc.CallOption) (*CreateDispetcherResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateDispetcherResponse)
	err := c.cc.Invoke(ctx, Dispetcher_CreateDispetcher_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dispetcherClient) GetDispetchers(ctx context.Context, in *GetDispetchersRequest, opts ...grpc.CallOption) (*GetDispetchersResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetDispetchersResponse)
	err := c.cc.Invoke(ctx, Dispetcher_GetDispetchers_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dispetcherClient) UpdateDispetcher(ctx context.Context, in *UpdateDispetcherRequest, opts ...grpc.CallOption) (*UpdateDispetcherResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateDispetcherResponse)
	err := c.cc.Invoke(ctx, Dispetcher_UpdateDispetcher_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dispetcherClient) DeleteDispetcher(ctx context.Context, in *DeleteDispetcherRequest, opts ...grpc.CallOption) (*DeleteDispetcherResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteDispetcherResponse)
	err := c.cc.Invoke(ctx, Dispetcher_DeleteDispetcher_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// DispetcherServer is the server API for Dispetcher service.
// All implementations must embed UnimplementedDispetcherServer
// for forward compatibility.
type DispetcherServer interface {
	CreateDispetcher(context.Context, *CreateDispetcherRequest) (*CreateDispetcherResponse, error)
	GetDispetchers(context.Context, *GetDispetchersRequest) (*GetDispetchersResponse, error)
	UpdateDispetcher(context.Context, *UpdateDispetcherRequest) (*UpdateDispetcherResponse, error)
	DeleteDispetcher(context.Context, *DeleteDispetcherRequest) (*DeleteDispetcherResponse, error)
	mustEmbedUnimplementedDispetcherServer()
}

// UnimplementedDispetcherServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedDispetcherServer struct{}

func (UnimplementedDispetcherServer) CreateDispetcher(context.Context, *CreateDispetcherRequest) (*CreateDispetcherResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateDispetcher not implemented")
}
func (UnimplementedDispetcherServer) GetDispetchers(context.Context, *GetDispetchersRequest) (*GetDispetchersResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetDispetchers not implemented")
}
func (UnimplementedDispetcherServer) UpdateDispetcher(context.Context, *UpdateDispetcherRequest) (*UpdateDispetcherResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateDispetcher not implemented")
}
func (UnimplementedDispetcherServer) DeleteDispetcher(context.Context, *DeleteDispetcherRequest) (*DeleteDispetcherResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteDispetcher not implemented")
}
func (UnimplementedDispetcherServer) mustEmbedUnimplementedDispetcherServer() {}
func (UnimplementedDispetcherServer) testEmbeddedByValue()                    {}

// UnsafeDispetcherServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to DispetcherServer will
// result in compilation errors.
type UnsafeDispetcherServer interface {
	mustEmbedUnimplementedDispetcherServer()
}

func RegisterDispetcherServer(s grpc.ServiceRegistrar, srv DispetcherServer) {
	// If the following call pancis, it indicates UnimplementedDispetcherServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&Dispetcher_ServiceDesc, srv)
}

func _Dispetcher_CreateDispetcher_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateDispetcherRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DispetcherServer).CreateDispetcher(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Dispetcher_CreateDispetcher_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DispetcherServer).CreateDispetcher(ctx, req.(*CreateDispetcherRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Dispetcher_GetDispetchers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetDispetchersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DispetcherServer).GetDispetchers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Dispetcher_GetDispetchers_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DispetcherServer).GetDispetchers(ctx, req.(*GetDispetchersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Dispetcher_UpdateDispetcher_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateDispetcherRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DispetcherServer).UpdateDispetcher(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Dispetcher_UpdateDispetcher_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DispetcherServer).UpdateDispetcher(ctx, req.(*UpdateDispetcherRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Dispetcher_DeleteDispetcher_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteDispetcherRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DispetcherServer).DeleteDispetcher(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Dispetcher_DeleteDispetcher_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DispetcherServer).DeleteDispetcher(ctx, req.(*DeleteDispetcherRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Dispetcher_ServiceDesc is the grpc.ServiceDesc for Dispetcher service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Dispetcher_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "document.Dispetcher",
	HandlerType: (*DispetcherServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateDispetcher",
			Handler:    _Dispetcher_CreateDispetcher_Handler,
		},
		{
			MethodName: "GetDispetchers",
			Handler:    _Dispetcher_GetDispetchers_Handler,
		},
		{
			MethodName: "UpdateDispetcher",
			Handler:    _Dispetcher_UpdateDispetcher_Handler,
		},
		{
			MethodName: "DeleteDispetcher",
			Handler:    _Dispetcher_DeleteDispetcher_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "document.proto",
}

const (
	Mehanic_CreateMehanic_FullMethodName = "/document.Mehanic/CreateMehanic"
	Mehanic_GetMehanics_FullMethodName   = "/document.Mehanic/GetMehanics"
	Mehanic_UpdateMehanic_FullMethodName = "/document.Mehanic/UpdateMehanic"
	Mehanic_DeleteMehanic_FullMethodName = "/document.Mehanic/DeleteMehanic"
)

// MehanicClient is the client API for Mehanic service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type MehanicClient interface {
	CreateMehanic(ctx context.Context, in *CreateMehanicRequest, opts ...grpc.CallOption) (*CreateMehanicResponse, error)
	GetMehanics(ctx context.Context, in *GetMehanicsRequest, opts ...grpc.CallOption) (*GetMehanicsResponse, error)
	UpdateMehanic(ctx context.Context, in *UpdateMehanicRequest, opts ...grpc.CallOption) (*UpdateMehanicResponse, error)
	DeleteMehanic(ctx context.Context, in *DeleteMehanicRequest, opts ...grpc.CallOption) (*DeleteMehanicResponse, error)
}

type mehanicClient struct {
	cc grpc.ClientConnInterface
}

func NewMehanicClient(cc grpc.ClientConnInterface) MehanicClient {
	return &mehanicClient{cc}
}

func (c *mehanicClient) CreateMehanic(ctx context.Context, in *CreateMehanicRequest, opts ...grpc.CallOption) (*CreateMehanicResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateMehanicResponse)
	err := c.cc.Invoke(ctx, Mehanic_CreateMehanic_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mehanicClient) GetMehanics(ctx context.Context, in *GetMehanicsRequest, opts ...grpc.CallOption) (*GetMehanicsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetMehanicsResponse)
	err := c.cc.Invoke(ctx, Mehanic_GetMehanics_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mehanicClient) UpdateMehanic(ctx context.Context, in *UpdateMehanicRequest, opts ...grpc.CallOption) (*UpdateMehanicResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateMehanicResponse)
	err := c.cc.Invoke(ctx, Mehanic_UpdateMehanic_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mehanicClient) DeleteMehanic(ctx context.Context, in *DeleteMehanicRequest, opts ...grpc.CallOption) (*DeleteMehanicResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteMehanicResponse)
	err := c.cc.Invoke(ctx, Mehanic_DeleteMehanic_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MehanicServer is the server API for Mehanic service.
// All implementations must embed UnimplementedMehanicServer
// for forward compatibility.
type MehanicServer interface {
	CreateMehanic(context.Context, *CreateMehanicRequest) (*CreateMehanicResponse, error)
	GetMehanics(context.Context, *GetMehanicsRequest) (*GetMehanicsResponse, error)
	UpdateMehanic(context.Context, *UpdateMehanicRequest) (*UpdateMehanicResponse, error)
	DeleteMehanic(context.Context, *DeleteMehanicRequest) (*DeleteMehanicResponse, error)
	mustEmbedUnimplementedMehanicServer()
}

// UnimplementedMehanicServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedMehanicServer struct{}

func (UnimplementedMehanicServer) CreateMehanic(context.Context, *CreateMehanicRequest) (*CreateMehanicResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateMehanic not implemented")
}
func (UnimplementedMehanicServer) GetMehanics(context.Context, *GetMehanicsRequest) (*GetMehanicsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetMehanics not implemented")
}
func (UnimplementedMehanicServer) UpdateMehanic(context.Context, *UpdateMehanicRequest) (*UpdateMehanicResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateMehanic not implemented")
}
func (UnimplementedMehanicServer) DeleteMehanic(context.Context, *DeleteMehanicRequest) (*DeleteMehanicResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteMehanic not implemented")
}
func (UnimplementedMehanicServer) mustEmbedUnimplementedMehanicServer() {}
func (UnimplementedMehanicServer) testEmbeddedByValue()                 {}

// UnsafeMehanicServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to MehanicServer will
// result in compilation errors.
type UnsafeMehanicServer interface {
	mustEmbedUnimplementedMehanicServer()
}

func RegisterMehanicServer(s grpc.ServiceRegistrar, srv MehanicServer) {
	// If the following call pancis, it indicates UnimplementedMehanicServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&Mehanic_ServiceDesc, srv)
}

func _Mehanic_CreateMehanic_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateMehanicRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MehanicServer).CreateMehanic(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Mehanic_CreateMehanic_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MehanicServer).CreateMehanic(ctx, req.(*CreateMehanicRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Mehanic_GetMehanics_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetMehanicsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MehanicServer).GetMehanics(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Mehanic_GetMehanics_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MehanicServer).GetMehanics(ctx, req.(*GetMehanicsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Mehanic_UpdateMehanic_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateMehanicRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MehanicServer).UpdateMehanic(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Mehanic_UpdateMehanic_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MehanicServer).UpdateMehanic(ctx, req.(*UpdateMehanicRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Mehanic_DeleteMehanic_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteMehanicRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MehanicServer).DeleteMehanic(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Mehanic_DeleteMehanic_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MehanicServer).DeleteMehanic(ctx, req.(*DeleteMehanicRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Mehanic_ServiceDesc is the grpc.ServiceDesc for Mehanic service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Mehanic_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "document.Mehanic",
	HandlerType: (*MehanicServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateMehanic",
			Handler:    _Mehanic_CreateMehanic_Handler,
		},
		{
			MethodName: "GetMehanics",
			Handler:    _Mehanic_GetMehanics_Handler,
		},
		{
			MethodName: "UpdateMehanic",
			Handler:    _Mehanic_UpdateMehanic_Handler,
		},
		{
			MethodName: "DeleteMehanic",
			Handler:    _Mehanic_DeleteMehanic_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "document.proto",
}

const (
	Driver_CreateDriver_FullMethodName = "/document.Driver/CreateDriver"
	Driver_GetDrivers_FullMethodName   = "/document.Driver/GetDrivers"
	Driver_UpdateDriver_FullMethodName = "/document.Driver/UpdateDriver"
	Driver_DeleteDriver_FullMethodName = "/document.Driver/DeleteDriver"
)

// DriverClient is the client API for Driver service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type DriverClient interface {
	CreateDriver(ctx context.Context, in *CreateDriverRequest, opts ...grpc.CallOption) (*CreateDriverResponse, error)
	GetDrivers(ctx context.Context, in *GetDriversRequest, opts ...grpc.CallOption) (*GetDriversResponse, error)
	UpdateDriver(ctx context.Context, in *UpdateDriverRequest, opts ...grpc.CallOption) (*UpdateDriverResponse, error)
	DeleteDriver(ctx context.Context, in *DeleteDriverRequest, opts ...grpc.CallOption) (*DeleteDriverResponse, error)
}

type driverClient struct {
	cc grpc.ClientConnInterface
}

func NewDriverClient(cc grpc.ClientConnInterface) DriverClient {
	return &driverClient{cc}
}

func (c *driverClient) CreateDriver(ctx context.Context, in *CreateDriverRequest, opts ...grpc.CallOption) (*CreateDriverResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateDriverResponse)
	err := c.cc.Invoke(ctx, Driver_CreateDriver_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *driverClient) GetDrivers(ctx context.Context, in *GetDriversRequest, opts ...grpc.CallOption) (*GetDriversResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetDriversResponse)
	err := c.cc.Invoke(ctx, Driver_GetDrivers_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *driverClient) UpdateDriver(ctx context.Context, in *UpdateDriverRequest, opts ...grpc.CallOption) (*UpdateDriverResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateDriverResponse)
	err := c.cc.Invoke(ctx, Driver_UpdateDriver_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *driverClient) DeleteDriver(ctx context.Context, in *DeleteDriverRequest, opts ...grpc.CallOption) (*DeleteDriverResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteDriverResponse)
	err := c.cc.Invoke(ctx, Driver_DeleteDriver_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// DriverServer is the server API for Driver service.
// All implementations must embed UnimplementedDriverServer
// for forward compatibility.
type DriverServer interface {
	CreateDriver(context.Context, *CreateDriverRequest) (*CreateDriverResponse, error)
	GetDrivers(context.Context, *GetDriversRequest) (*GetDriversResponse, error)
	UpdateDriver(context.Context, *UpdateDriverRequest) (*UpdateDriverResponse, error)
	DeleteDriver(context.Context, *DeleteDriverRequest) (*DeleteDriverResponse, error)
	mustEmbedUnimplementedDriverServer()
}

// UnimplementedDriverServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedDriverServer struct{}

func (UnimplementedDriverServer) CreateDriver(context.Context, *CreateDriverRequest) (*CreateDriverResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateDriver not implemented")
}
func (UnimplementedDriverServer) GetDrivers(context.Context, *GetDriversRequest) (*GetDriversResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetDrivers not implemented")
}
func (UnimplementedDriverServer) UpdateDriver(context.Context, *UpdateDriverRequest) (*UpdateDriverResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateDriver not implemented")
}
func (UnimplementedDriverServer) DeleteDriver(context.Context, *DeleteDriverRequest) (*DeleteDriverResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteDriver not implemented")
}
func (UnimplementedDriverServer) mustEmbedUnimplementedDriverServer() {}
func (UnimplementedDriverServer) testEmbeddedByValue()                {}

// UnsafeDriverServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to DriverServer will
// result in compilation errors.
type UnsafeDriverServer interface {
	mustEmbedUnimplementedDriverServer()
}

func RegisterDriverServer(s grpc.ServiceRegistrar, srv DriverServer) {
	// If the following call pancis, it indicates UnimplementedDriverServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&Driver_ServiceDesc, srv)
}

func _Driver_CreateDriver_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateDriverRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DriverServer).CreateDriver(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Driver_CreateDriver_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DriverServer).CreateDriver(ctx, req.(*CreateDriverRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Driver_GetDrivers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetDriversRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DriverServer).GetDrivers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Driver_GetDrivers_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DriverServer).GetDrivers(ctx, req.(*GetDriversRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Driver_UpdateDriver_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateDriverRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DriverServer).UpdateDriver(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Driver_UpdateDriver_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DriverServer).UpdateDriver(ctx, req.(*UpdateDriverRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Driver_DeleteDriver_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteDriverRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DriverServer).DeleteDriver(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Driver_DeleteDriver_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DriverServer).DeleteDriver(ctx, req.(*DeleteDriverRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Driver_ServiceDesc is the grpc.ServiceDesc for Driver service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Driver_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "document.Driver",
	HandlerType: (*DriverServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateDriver",
			Handler:    _Driver_CreateDriver_Handler,
		},
		{
			MethodName: "GetDrivers",
			Handler:    _Driver_GetDrivers_Handler,
		},
		{
			MethodName: "UpdateDriver",
			Handler:    _Driver_UpdateDriver_Handler,
		},
		{
			MethodName: "DeleteDriver",
			Handler:    _Driver_DeleteDriver_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "document.proto",
}

const (
	Organization_CreateOrganization_FullMethodName = "/document.Organization/CreateOrganization"
	Organization_GetOrganizations_FullMethodName   = "/document.Organization/GetOrganizations"
	Organization_UpdateOrganization_FullMethodName = "/document.Organization/UpdateOrganization"
	Organization_DeleteOrganization_FullMethodName = "/document.Organization/DeleteOrganization"
)

// OrganizationClient is the client API for Organization service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type OrganizationClient interface {
	CreateOrganization(ctx context.Context, in *CreateOrganizationRequest, opts ...grpc.CallOption) (*CreateOrganizationResponse, error)
	GetOrganizations(ctx context.Context, in *GetOrganizationsRequest, opts ...grpc.CallOption) (*GetOrganizationsResponse, error)
	UpdateOrganization(ctx context.Context, in *UpdateOrganizationRequest, opts ...grpc.CallOption) (*UpdateOrganizationResponse, error)
	DeleteOrganization(ctx context.Context, in *DeleteOrganizationRequest, opts ...grpc.CallOption) (*DeleteOrganizationResponse, error)
}

type organizationClient struct {
	cc grpc.ClientConnInterface
}

func NewOrganizationClient(cc grpc.ClientConnInterface) OrganizationClient {
	return &organizationClient{cc}
}

func (c *organizationClient) CreateOrganization(ctx context.Context, in *CreateOrganizationRequest, opts ...grpc.CallOption) (*CreateOrganizationResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateOrganizationResponse)
	err := c.cc.Invoke(ctx, Organization_CreateOrganization_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *organizationClient) GetOrganizations(ctx context.Context, in *GetOrganizationsRequest, opts ...grpc.CallOption) (*GetOrganizationsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetOrganizationsResponse)
	err := c.cc.Invoke(ctx, Organization_GetOrganizations_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *organizationClient) UpdateOrganization(ctx context.Context, in *UpdateOrganizationRequest, opts ...grpc.CallOption) (*UpdateOrganizationResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateOrganizationResponse)
	err := c.cc.Invoke(ctx, Organization_UpdateOrganization_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *organizationClient) DeleteOrganization(ctx context.Context, in *DeleteOrganizationRequest, opts ...grpc.CallOption) (*DeleteOrganizationResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteOrganizationResponse)
	err := c.cc.Invoke(ctx, Organization_DeleteOrganization_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// OrganizationServer is the server API for Organization service.
// All implementations must embed UnimplementedOrganizationServer
// for forward compatibility.
type OrganizationServer interface {
	CreateOrganization(context.Context, *CreateOrganizationRequest) (*CreateOrganizationResponse, error)
	GetOrganizations(context.Context, *GetOrganizationsRequest) (*GetOrganizationsResponse, error)
	UpdateOrganization(context.Context, *UpdateOrganizationRequest) (*UpdateOrganizationResponse, error)
	DeleteOrganization(context.Context, *DeleteOrganizationRequest) (*DeleteOrganizationResponse, error)
	mustEmbedUnimplementedOrganizationServer()
}

// UnimplementedOrganizationServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedOrganizationServer struct{}

func (UnimplementedOrganizationServer) CreateOrganization(context.Context, *CreateOrganizationRequest) (*CreateOrganizationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateOrganization not implemented")
}
func (UnimplementedOrganizationServer) GetOrganizations(context.Context, *GetOrganizationsRequest) (*GetOrganizationsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetOrganizations not implemented")
}
func (UnimplementedOrganizationServer) UpdateOrganization(context.Context, *UpdateOrganizationRequest) (*UpdateOrganizationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateOrganization not implemented")
}
func (UnimplementedOrganizationServer) DeleteOrganization(context.Context, *DeleteOrganizationRequest) (*DeleteOrganizationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteOrganization not implemented")
}
func (UnimplementedOrganizationServer) mustEmbedUnimplementedOrganizationServer() {}
func (UnimplementedOrganizationServer) testEmbeddedByValue()                      {}

// UnsafeOrganizationServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to OrganizationServer will
// result in compilation errors.
type UnsafeOrganizationServer interface {
	mustEmbedUnimplementedOrganizationServer()
}

func RegisterOrganizationServer(s grpc.ServiceRegistrar, srv OrganizationServer) {
	// If the following call pancis, it indicates UnimplementedOrganizationServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&Organization_ServiceDesc, srv)
}

func _Organization_CreateOrganization_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateOrganizationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OrganizationServer).CreateOrganization(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Organization_CreateOrganization_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OrganizationServer).CreateOrganization(ctx, req.(*CreateOrganizationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Organization_GetOrganizations_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetOrganizationsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OrganizationServer).GetOrganizations(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Organization_GetOrganizations_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OrganizationServer).GetOrganizations(ctx, req.(*GetOrganizationsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Organization_UpdateOrganization_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateOrganizationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OrganizationServer).UpdateOrganization(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Organization_UpdateOrganization_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OrganizationServer).UpdateOrganization(ctx, req.(*UpdateOrganizationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Organization_DeleteOrganization_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteOrganizationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OrganizationServer).DeleteOrganization(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Organization_DeleteOrganization_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OrganizationServer).DeleteOrganization(ctx, req.(*DeleteOrganizationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Organization_ServiceDesc is the grpc.ServiceDesc for Organization service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Organization_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "document.Organization",
	HandlerType: (*OrganizationServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateOrganization",
			Handler:    _Organization_CreateOrganization_Handler,
		},
		{
			MethodName: "GetOrganizations",
			Handler:    _Organization_GetOrganizations_Handler,
		},
		{
			MethodName: "UpdateOrganization",
			Handler:    _Organization_UpdateOrganization_Handler,
		},
		{
			MethodName: "DeleteOrganization",
			Handler:    _Organization_DeleteOrganization_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "document.proto",
}

const (
	BankAccount_CreateBankAccount_FullMethodName = "/document.BankAccount/CreateBankAccount"
	BankAccount_GetBankAccounts_FullMethodName   = "/document.BankAccount/GetBankAccounts"
	BankAccount_UpdateBankAccount_FullMethodName = "/document.BankAccount/UpdateBankAccount"
	BankAccount_DeleteBankAccount_FullMethodName = "/document.BankAccount/DeleteBankAccount"
)

// BankAccountClient is the client API for BankAccount service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type BankAccountClient interface {
	CreateBankAccount(ctx context.Context, in *CreateBankAccountRequest, opts ...grpc.CallOption) (*CreateBankAccountResponse, error)
	GetBankAccounts(ctx context.Context, in *GetBankAccountsRequest, opts ...grpc.CallOption) (*GetBankAccountsResponse, error)
	UpdateBankAccount(ctx context.Context, in *UpdateBankAccountRequest, opts ...grpc.CallOption) (*UpdateBankAccountResponse, error)
	DeleteBankAccount(ctx context.Context, in *DeleteBankAccountRequest, opts ...grpc.CallOption) (*DeleteBankAccountResponse, error)
}

type bankAccountClient struct {
	cc grpc.ClientConnInterface
}

func NewBankAccountClient(cc grpc.ClientConnInterface) BankAccountClient {
	return &bankAccountClient{cc}
}

func (c *bankAccountClient) CreateBankAccount(ctx context.Context, in *CreateBankAccountRequest, opts ...grpc.CallOption) (*CreateBankAccountResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateBankAccountResponse)
	err := c.cc.Invoke(ctx, BankAccount_CreateBankAccount_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bankAccountClient) GetBankAccounts(ctx context.Context, in *GetBankAccountsRequest, opts ...grpc.CallOption) (*GetBankAccountsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetBankAccountsResponse)
	err := c.cc.Invoke(ctx, BankAccount_GetBankAccounts_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bankAccountClient) UpdateBankAccount(ctx context.Context, in *UpdateBankAccountRequest, opts ...grpc.CallOption) (*UpdateBankAccountResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateBankAccountResponse)
	err := c.cc.Invoke(ctx, BankAccount_UpdateBankAccount_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bankAccountClient) DeleteBankAccount(ctx context.Context, in *DeleteBankAccountRequest, opts ...grpc.CallOption) (*DeleteBankAccountResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteBankAccountResponse)
	err := c.cc.Invoke(ctx, BankAccount_DeleteBankAccount_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// BankAccountServer is the server API for BankAccount service.
// All implementations must embed UnimplementedBankAccountServer
// for forward compatibility.
type BankAccountServer interface {
	CreateBankAccount(context.Context, *CreateBankAccountRequest) (*CreateBankAccountResponse, error)
	GetBankAccounts(context.Context, *GetBankAccountsRequest) (*GetBankAccountsResponse, error)
	UpdateBankAccount(context.Context, *UpdateBankAccountRequest) (*UpdateBankAccountResponse, error)
	DeleteBankAccount(context.Context, *DeleteBankAccountRequest) (*DeleteBankAccountResponse, error)
	mustEmbedUnimplementedBankAccountServer()
}

// UnimplementedBankAccountServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedBankAccountServer struct{}

func (UnimplementedBankAccountServer) CreateBankAccount(context.Context, *CreateBankAccountRequest) (*CreateBankAccountResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateBankAccount not implemented")
}
func (UnimplementedBankAccountServer) GetBankAccounts(context.Context, *GetBankAccountsRequest) (*GetBankAccountsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetBankAccounts not implemented")
}
func (UnimplementedBankAccountServer) UpdateBankAccount(context.Context, *UpdateBankAccountRequest) (*UpdateBankAccountResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateBankAccount not implemented")
}
func (UnimplementedBankAccountServer) DeleteBankAccount(context.Context, *DeleteBankAccountRequest) (*DeleteBankAccountResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteBankAccount not implemented")
}
func (UnimplementedBankAccountServer) mustEmbedUnimplementedBankAccountServer() {}
func (UnimplementedBankAccountServer) testEmbeddedByValue()                     {}

// UnsafeBankAccountServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to BankAccountServer will
// result in compilation errors.
type UnsafeBankAccountServer interface {
	mustEmbedUnimplementedBankAccountServer()
}

func RegisterBankAccountServer(s grpc.ServiceRegistrar, srv BankAccountServer) {
	// If the following call pancis, it indicates UnimplementedBankAccountServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&BankAccount_ServiceDesc, srv)
}

func _BankAccount_CreateBankAccount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateBankAccountRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BankAccountServer).CreateBankAccount(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BankAccount_CreateBankAccount_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BankAccountServer).CreateBankAccount(ctx, req.(*CreateBankAccountRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BankAccount_GetBankAccounts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetBankAccountsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BankAccountServer).GetBankAccounts(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BankAccount_GetBankAccounts_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BankAccountServer).GetBankAccounts(ctx, req.(*GetBankAccountsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BankAccount_UpdateBankAccount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateBankAccountRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BankAccountServer).UpdateBankAccount(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BankAccount_UpdateBankAccount_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BankAccountServer).UpdateBankAccount(ctx, req.(*UpdateBankAccountRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BankAccount_DeleteBankAccount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteBankAccountRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BankAccountServer).DeleteBankAccount(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BankAccount_DeleteBankAccount_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BankAccountServer).DeleteBankAccount(ctx, req.(*DeleteBankAccountRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// BankAccount_ServiceDesc is the grpc.ServiceDesc for BankAccount service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var BankAccount_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "document.BankAccount",
	HandlerType: (*BankAccountServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateBankAccount",
			Handler:    _BankAccount_CreateBankAccount_Handler,
		},
		{
			MethodName: "GetBankAccounts",
			Handler:    _BankAccount_GetBankAccounts_Handler,
		},
		{
			MethodName: "UpdateBankAccount",
			Handler:    _BankAccount_UpdateBankAccount_Handler,
		},
		{
			MethodName: "DeleteBankAccount",
			Handler:    _BankAccount_DeleteBankAccount_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "document.proto",
}

const (
	Putlist_CreatePutlist_FullMethodName      = "/document.Putlist/CreatePutlist"
	Putlist_GetPutlists_FullMethodName        = "/document.Putlist/GetPutlists"
	Putlist_GetPutlistByNumber_FullMethodName = "/document.Putlist/GetPutlistByNumber"
	Putlist_UpdatePutlist_FullMethodName      = "/document.Putlist/UpdatePutlist"
	Putlist_DeletePutlist_FullMethodName      = "/document.Putlist/DeletePutlist"
)

// PutlistClient is the client API for Putlist service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type PutlistClient interface {
	CreatePutlist(ctx context.Context, in *CreatePutlistRequest, opts ...grpc.CallOption) (*CreatePutlistResponse, error)
	GetPutlists(ctx context.Context, in *GetPutlistsRequest, opts ...grpc.CallOption) (*GetPutlistsResponse, error)
	GetPutlistByNumber(ctx context.Context, in *GetPutlistByNumberRequest, opts ...grpc.CallOption) (*GetPutlistByNumberResponse, error)
	UpdatePutlist(ctx context.Context, in *UpdatePutlistRequest, opts ...grpc.CallOption) (*UpdatePutlistResponse, error)
	DeletePutlist(ctx context.Context, in *DeletePutlistRequest, opts ...grpc.CallOption) (*DeletePutlistResponse, error)
}

type putlistClient struct {
	cc grpc.ClientConnInterface
}

func NewPutlistClient(cc grpc.ClientConnInterface) PutlistClient {
	return &putlistClient{cc}
}

func (c *putlistClient) CreatePutlist(ctx context.Context, in *CreatePutlistRequest, opts ...grpc.CallOption) (*CreatePutlistResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreatePutlistResponse)
	err := c.cc.Invoke(ctx, Putlist_CreatePutlist_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *putlistClient) GetPutlists(ctx context.Context, in *GetPutlistsRequest, opts ...grpc.CallOption) (*GetPutlistsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetPutlistsResponse)
	err := c.cc.Invoke(ctx, Putlist_GetPutlists_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *putlistClient) GetPutlistByNumber(ctx context.Context, in *GetPutlistByNumberRequest, opts ...grpc.CallOption) (*GetPutlistByNumberResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetPutlistByNumberResponse)
	err := c.cc.Invoke(ctx, Putlist_GetPutlistByNumber_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *putlistClient) UpdatePutlist(ctx context.Context, in *UpdatePutlistRequest, opts ...grpc.CallOption) (*UpdatePutlistResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdatePutlistResponse)
	err := c.cc.Invoke(ctx, Putlist_UpdatePutlist_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *putlistClient) DeletePutlist(ctx context.Context, in *DeletePutlistRequest, opts ...grpc.CallOption) (*DeletePutlistResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeletePutlistResponse)
	err := c.cc.Invoke(ctx, Putlist_DeletePutlist_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// PutlistServer is the server API for Putlist service.
// All implementations must embed UnimplementedPutlistServer
// for forward compatibility.
type PutlistServer interface {
	CreatePutlist(context.Context, *CreatePutlistRequest) (*CreatePutlistResponse, error)
	GetPutlists(context.Context, *GetPutlistsRequest) (*GetPutlistsResponse, error)
	GetPutlistByNumber(context.Context, *GetPutlistByNumberRequest) (*GetPutlistByNumberResponse, error)
	UpdatePutlist(context.Context, *UpdatePutlistRequest) (*UpdatePutlistResponse, error)
	DeletePutlist(context.Context, *DeletePutlistRequest) (*DeletePutlistResponse, error)
	mustEmbedUnimplementedPutlistServer()
}

// UnimplementedPutlistServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedPutlistServer struct{}

func (UnimplementedPutlistServer) CreatePutlist(context.Context, *CreatePutlistRequest) (*CreatePutlistResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreatePutlist not implemented")
}
func (UnimplementedPutlistServer) GetPutlists(context.Context, *GetPutlistsRequest) (*GetPutlistsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetPutlists not implemented")
}
func (UnimplementedPutlistServer) GetPutlistByNumber(context.Context, *GetPutlistByNumberRequest) (*GetPutlistByNumberResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetPutlistByNumber not implemented")
}
func (UnimplementedPutlistServer) UpdatePutlist(context.Context, *UpdatePutlistRequest) (*UpdatePutlistResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdatePutlist not implemented")
}
func (UnimplementedPutlistServer) DeletePutlist(context.Context, *DeletePutlistRequest) (*DeletePutlistResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeletePutlist not implemented")
}
func (UnimplementedPutlistServer) mustEmbedUnimplementedPutlistServer() {}
func (UnimplementedPutlistServer) testEmbeddedByValue()                 {}

// UnsafePutlistServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to PutlistServer will
// result in compilation errors.
type UnsafePutlistServer interface {
	mustEmbedUnimplementedPutlistServer()
}

func RegisterPutlistServer(s grpc.ServiceRegistrar, srv PutlistServer) {
	// If the following call pancis, it indicates UnimplementedPutlistServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&Putlist_ServiceDesc, srv)
}

func _Putlist_CreatePutlist_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreatePutlistRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PutlistServer).CreatePutlist(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Putlist_CreatePutlist_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PutlistServer).CreatePutlist(ctx, req.(*CreatePutlistRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Putlist_GetPutlists_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetPutlistsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PutlistServer).GetPutlists(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Putlist_GetPutlists_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PutlistServer).GetPutlists(ctx, req.(*GetPutlistsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Putlist_GetPutlistByNumber_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetPutlistByNumberRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PutlistServer).GetPutlistByNumber(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Putlist_GetPutlistByNumber_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PutlistServer).GetPutlistByNumber(ctx, req.(*GetPutlistByNumberRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Putlist_UpdatePutlist_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdatePutlistRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PutlistServer).UpdatePutlist(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Putlist_UpdatePutlist_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PutlistServer).UpdatePutlist(ctx, req.(*UpdatePutlistRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Putlist_DeletePutlist_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeletePutlistRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PutlistServer).DeletePutlist(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Putlist_DeletePutlist_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PutlistServer).DeletePutlist(ctx, req.(*DeletePutlistRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Putlist_ServiceDesc is the grpc.ServiceDesc for Putlist service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Putlist_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "document.Putlist",
	HandlerType: (*PutlistServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreatePutlist",
			Handler:    _Putlist_CreatePutlist_Handler,
		},
		{
			MethodName: "GetPutlists",
			Handler:    _Putlist_GetPutlists_Handler,
		},
		{
			MethodName: "GetPutlistByNumber",
			Handler:    _Putlist_GetPutlistByNumber_Handler,
		},
		{
			MethodName: "UpdatePutlist",
			Handler:    _Putlist_UpdatePutlist_Handler,
		},
		{
			MethodName: "DeletePutlist",
			Handler:    _Putlist_DeletePutlist_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "document.proto",
}

const (
	PutlistBody_CreatePutlistBody_FullMethodName = "/document.PutlistBody/CreatePutlistBody"
	PutlistBody_GetPutlistBodies_FullMethodName  = "/document.PutlistBody/GetPutlistBodies"
	PutlistBody_UpdatePutlistBody_FullMethodName = "/document.PutlistBody/UpdatePutlistBody"
	PutlistBody_DeletePutlistBody_FullMethodName = "/document.PutlistBody/DeletePutlistBody"
)

// PutlistBodyClient is the client API for PutlistBody service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type PutlistBodyClient interface {
	CreatePutlistBody(ctx context.Context, in *CreatePutlistBodyRequest, opts ...grpc.CallOption) (*CreatePutlistBodyResponse, error)
	GetPutlistBodies(ctx context.Context, in *GetPutlistBodiesRequest, opts ...grpc.CallOption) (*GetPutlistBodiesResponse, error)
	UpdatePutlistBody(ctx context.Context, in *UpdatePutlistBodyRequest, opts ...grpc.CallOption) (*UpdatePutlistBodyResponse, error)
	DeletePutlistBody(ctx context.Context, in *DeletePutlistBodyRequest, opts ...grpc.CallOption) (*DeletePutlistBodyResponse, error)
}

type putlistBodyClient struct {
	cc grpc.ClientConnInterface
}

func NewPutlistBodyClient(cc grpc.ClientConnInterface) PutlistBodyClient {
	return &putlistBodyClient{cc}
}

func (c *putlistBodyClient) CreatePutlistBody(ctx context.Context, in *CreatePutlistBodyRequest, opts ...grpc.CallOption) (*CreatePutlistBodyResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreatePutlistBodyResponse)
	err := c.cc.Invoke(ctx, PutlistBody_CreatePutlistBody_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *putlistBodyClient) GetPutlistBodies(ctx context.Context, in *GetPutlistBodiesRequest, opts ...grpc.CallOption) (*GetPutlistBodiesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetPutlistBodiesResponse)
	err := c.cc.Invoke(ctx, PutlistBody_GetPutlistBodies_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *putlistBodyClient) UpdatePutlistBody(ctx context.Context, in *UpdatePutlistBodyRequest, opts ...grpc.CallOption) (*UpdatePutlistBodyResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdatePutlistBodyResponse)
	err := c.cc.Invoke(ctx, PutlistBody_UpdatePutlistBody_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *putlistBodyClient) DeletePutlistBody(ctx context.Context, in *DeletePutlistBodyRequest, opts ...grpc.CallOption) (*DeletePutlistBodyResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeletePutlistBodyResponse)
	err := c.cc.Invoke(ctx, PutlistBody_DeletePutlistBody_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// PutlistBodyServer is the server API for PutlistBody service.
// All implementations must embed UnimplementedPutlistBodyServer
// for forward compatibility.
type PutlistBodyServer interface {
	CreatePutlistBody(context.Context, *CreatePutlistBodyRequest) (*CreatePutlistBodyResponse, error)
	GetPutlistBodies(context.Context, *GetPutlistBodiesRequest) (*GetPutlistBodiesResponse, error)
	UpdatePutlistBody(context.Context, *UpdatePutlistBodyRequest) (*UpdatePutlistBodyResponse, error)
	DeletePutlistBody(context.Context, *DeletePutlistBodyRequest) (*DeletePutlistBodyResponse, error)
	mustEmbedUnimplementedPutlistBodyServer()
}

// UnimplementedPutlistBodyServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedPutlistBodyServer struct{}

func (UnimplementedPutlistBodyServer) CreatePutlistBody(context.Context, *CreatePutlistBodyRequest) (*CreatePutlistBodyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreatePutlistBody not implemented")
}
func (UnimplementedPutlistBodyServer) GetPutlistBodies(context.Context, *GetPutlistBodiesRequest) (*GetPutlistBodiesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetPutlistBodies not implemented")
}
func (UnimplementedPutlistBodyServer) UpdatePutlistBody(context.Context, *UpdatePutlistBodyRequest) (*UpdatePutlistBodyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdatePutlistBody not implemented")
}
func (UnimplementedPutlistBodyServer) DeletePutlistBody(context.Context, *DeletePutlistBodyRequest) (*DeletePutlistBodyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeletePutlistBody not implemented")
}
func (UnimplementedPutlistBodyServer) mustEmbedUnimplementedPutlistBodyServer() {}
func (UnimplementedPutlistBodyServer) testEmbeddedByValue()                     {}

// UnsafePutlistBodyServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to PutlistBodyServer will
// result in compilation errors.
type UnsafePutlistBodyServer interface {
	mustEmbedUnimplementedPutlistBodyServer()
}

func RegisterPutlistBodyServer(s grpc.ServiceRegistrar, srv PutlistBodyServer) {
	// If the following call pancis, it indicates UnimplementedPutlistBodyServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&PutlistBody_ServiceDesc, srv)
}

func _PutlistBody_CreatePutlistBody_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreatePutlistBodyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PutlistBodyServer).CreatePutlistBody(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PutlistBody_CreatePutlistBody_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PutlistBodyServer).CreatePutlistBody(ctx, req.(*CreatePutlistBodyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PutlistBody_GetPutlistBodies_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetPutlistBodiesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PutlistBodyServer).GetPutlistBodies(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PutlistBody_GetPutlistBodies_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PutlistBodyServer).GetPutlistBodies(ctx, req.(*GetPutlistBodiesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PutlistBody_UpdatePutlistBody_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdatePutlistBodyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PutlistBodyServer).UpdatePutlistBody(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PutlistBody_UpdatePutlistBody_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PutlistBodyServer).UpdatePutlistBody(ctx, req.(*UpdatePutlistBodyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PutlistBody_DeletePutlistBody_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeletePutlistBodyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PutlistBodyServer).DeletePutlistBody(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PutlistBody_DeletePutlistBody_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PutlistBodyServer).DeletePutlistBody(ctx, req.(*DeletePutlistBodyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// PutlistBody_ServiceDesc is the grpc.ServiceDesc for PutlistBody service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var PutlistBody_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "document.PutlistBody",
	HandlerType: (*PutlistBodyServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreatePutlistBody",
			Handler:    _PutlistBody_CreatePutlistBody_Handler,
		},
		{
			MethodName: "GetPutlistBodies",
			Handler:    _PutlistBody_GetPutlistBodies_Handler,
		},
		{
			MethodName: "UpdatePutlistBody",
			Handler:    _PutlistBody_UpdatePutlistBody_Handler,
		},
		{
			MethodName: "DeletePutlistBody",
			Handler:    _PutlistBody_DeletePutlistBody_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "document.proto",
}
